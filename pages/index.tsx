import { HostedPageLayout, ThemeProvider } from '@awell-health/ui-library'
import * as Sentry from '@sentry/nextjs'
import { defaultTo, isNil } from 'lodash'
import { useTranslation } from 'next-i18next'
import { serverSideTranslations } from 'next-i18next/serverSideTranslations'
import Head from 'next/head'
import Image from 'next/image'
import { useRouter } from 'next/router'
import {
  ReactElement,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react'
import { ToastContainer } from 'react-toastify'
import 'react-toastify/dist/ReactToastify.css'
import useLocalStorage from 'use-local-storage'
import awell_logo from '../src/assets/logo.svg'
import {
  ActivitiesContainer,
  CloseHostedSessionModal,
  ErrorPage,
  LoadingPage,
} from '../src/components'
import { InvalidSessionPage } from '../src/components/InvalidSessionPage'
import { NetworkErrorPage } from '../src/components/NetworkErrorPage'
import { SessionExpiredPage } from '../src/components/SessionExpiredPage'
import { SuccessPage } from '../src/components/SuccessPage'
import { AWELL_BRAND_COLOR } from '../src/config'
import { useConnectivity } from '../src/contexts/ConnectivityContext'
import { useNetworkError } from '../src/contexts/NetworkErrorContext'
import { useHostedSession } from '../src/hooks/useHostedSession'
import { HostedSession } from '../src/hooks/useHostedSession/types'
import { useSessionStorage } from '../src/hooks/useSessionStorage'
import { HostedSessionLayout } from '../src/layouts'
import { HostedSessionStatus } from '../src/types/generated/types-orchestration'
import { validateLocale } from '../src/utils'
import { serializeError } from '../src/utils/errors'
import { LogEvent, logger } from '../src/utils/logging'
import { NextPageWithLayout } from './_app'

// Handles Session URLs generated by Start Hosted Pathway/Activities Session mutation
// i.e. https://goto.awell.health/en?sessionId=e-Dmjxm3E5AW
const Home: NextPageWithLayout = () => {
  const { t } = useTranslation()
  const {
    loading: sessionLoading,
    session,
    branding,
    theme,
    error,
    refetch,
    startPolling,
    stopPolling,
  } = useHostedSession()
  const { registerPollingTask } = useConnectivity()
  const { removeItem: removeAccessToken } = useSessionStorage('accessToken', '')
  const [logoOverride, setLogoOverride] = useLocalStorage(
    'awell-hp-logo-override',
    ''
  )
  const router = useRouter()
  const {
    hasNetworkError,
    networkErrorCount,
    setNetworkError,
    resetNetworkErrorCount,
  } = useNetworkError()

  const [isCloseHostedSessionModalOpen, setIsCloseHostedSessionModalOpen] =
    useState(false)
  const [showInvalidSession, setShowInvalidSession] = useState(false)

  // Register hosted session polling with connectivity so it starts when connected and stops when offline/hidden
  useEffect(() => {
    return registerPollingTask({
      start: () => startPolling(2000),
      stop: () => stopPolling(),
    })
  }, [registerPollingTask, startPolling, stopPolling])

  const handleNetworkErrorRetry = useCallback(async () => {
    try {
      const res = await refetch?.()

      const refetchedSession = res?.data?.hostedSession?.session
      if (refetchedSession) {
        resetNetworkErrorCount()
        setNetworkError(false)
        setShowInvalidSession(false)

        Sentry.logger?.info('Network error retry successful', {
          category: 'generic',
          message: 'Network error retry successful',
        })
        return
      }

      // No session and no unauthorized â†’ treat as invalid
      setShowInvalidSession(true)
      setNetworkError(false)
    } catch (err) {
      setNetworkError(true)

      Sentry.logger?.error('Network error retry failed', {
        category: 'generic',
        message: 'Network error retry failed',
        error: serializeError(err),
      })
    }
  }, [
    refetch,
    resetNetworkErrorCount,
    setNetworkError,
    setShowInvalidSession,
    router.query.sessionId,
  ])

  const { redirectAfterSession, shouldRedirect } = useRedirectAfterSession({
    setLogoOverride,
    router,
    session,
  })

  const onOpenCloseHostedSessionModal = () => {
    setIsCloseHostedSessionModalOpen(true)
  }

  const onCloseHostedSessionModal = () => {
    setIsCloseHostedSessionModalOpen(false)
  }

  const onCloseHostedSession = () => {
    Sentry.logger?.info('Session cancelled', {
      category: 'session_cancel',
    })
    router.push(session?.cancel_url ?? 'https://awell.health')
  }

  const hideCloseButton =
    (session?.status !== HostedSessionStatus.Active && !shouldRedirect) ||
    !theme?.layout?.showCloseButton

  useEffect(() => {
    if (isNil(session?.status)) {
      Sentry.logger?.warn('Session status is null', {
        category: 'generic',
        session,
        message: 'Session status is null',
        organization_slug: session?.organization_slug,
      })
      return
    }
    if (typeof window === 'undefined') {
      Sentry.logger?.warn('Window is undefined', {
        category: 'generic',
        message: 'Window is undefined',
      })
      return
    }

    switch (session?.status) {
      case HostedSessionStatus.Completed: {
        logger.info('Hosted session is completed', LogEvent.SESSION_COMPLETED, {
          sessionStatus: session?.status,
          session,
        })
        Sentry.logger?.info('Session completed', {
          category: 'session_complete',
          organization_slug: session?.organization_slug,
        })
        // Remove access token when session is completed
        removeAccessToken()
        if (shouldRedirect) {
          redirectAfterSession(session.success_url as string)
        }
        return
      }
      case HostedSessionStatus.Expired: {
        logger.info('Hosted session is expired', LogEvent.SESSION_EXPIRED, {
          sessionStatus: session?.status,
          session,
        })
        Sentry.logger?.info('Session expired', {
          category: 'session_expire',
          organization_slug: session?.organization_slug,
        })
        // Remove access token when session is expired
        removeAccessToken()
        if (shouldRedirect) {
          redirectAfterSession(session.cancel_url as string)
        }
        return
      }
      default: {
        logger.info('Hosted session is ongoing', LogEvent.SESSION_ONGOING, {
          session,
        })
        return
      }
    }
  }, [session, shouldRedirect, redirectAfterSession, removeAccessToken])

  // content now handled by SessionRouter component
  const logo = useLogo(theme, branding, logoOverride)

  // Show network error page if retry link failed after 3 attempts
  if (hasNetworkError && networkErrorCount >= 3) {
    const sessionId = router.query.sessionId as string | undefined
    return (
      <NetworkErrorGate
        show={true}
        branding={branding}
        logo={logo}
        onCloseHostedPage={onOpenCloseHostedSessionModal}
        onRetry={handleNetworkErrorRetry}
        sessionId={sessionId}
      />
    )
  }

  // Show invalid session page after successful retry but no valid session
  if (showInvalidSession) {
    const sessionId = router.query.sessionId as string | undefined
    const errorType = error === 'UNAUTHORIZED' ? 'unauthorized' : 'not_found'
    return (
      <InvalidSessionGate
        show={true}
        branding={branding}
        logo={logo}
        onCloseHostedPage={onOpenCloseHostedSessionModal}
        sessionId={sessionId}
        errorType={errorType}
      />
    )
  }

  if (sessionLoading) {
    return <LoadingPage showLogoBox={true} />
  }

  return (
    <>
      <Head>
        <title>{defaultTo(branding?.hosted_page_title, t('seo.title'))}</title>
        <meta property="og:title" content={t('seo.title')} key="title" />
        <meta name="description" content={t('seo.description')} />
      </Head>
      <ThemeProvider accentColor={branding?.accent_color || AWELL_BRAND_COLOR}>
        <HostedPageLayout
          logo={logo}
          onCloseHostedPage={onOpenCloseHostedSessionModal}
          hideCloseButton={hideCloseButton}
        >
          <SessionRouter
            key={`session-router-${session?.id}-${session?.status}`}
            session={session}
            shouldRedirect={shouldRedirect}
          />
          {error && (
            <ErrorPage
              title={
                error === 'UNAUTHORIZED'
                  ? t('session.session_completed_or_expired')
                  : t('session.loading_error')
              }
              onRetry={() => window.location.reload()}
            />
          )}
          <ToastContainer
            position="bottom-right"
            newestOnTop
            closeOnClick
            pauseOnFocusLoss
            autoClose={12000}
            hideProgressBar
            draggable
          />
          <CloseHostedSessionModal
            isModalOpen={isCloseHostedSessionModalOpen}
            onCloseHostedSession={onCloseHostedSession}
            onCloseModal={onCloseHostedSessionModal}
          />
        </HostedPageLayout>
      </ThemeProvider>
    </>
  )
}

Home.getLayout = function getLayout(page: ReactElement) {
  return <HostedSessionLayout>{page}</HostedSessionLayout>
}

export default Home

export async function getStaticProps({ locale }: { locale: string }) {
  // Validate and normalize the locale, falling back to 'en' if misconfigured
  const validatedLocale = validateLocale(locale)

  return {
    props: {
      ...(await serverSideTranslations(validatedLocale, ['common'])),
    },
  }
}

// Redirect and breadcrumb timing constants
const REDIRECT_DELAY_MS = 2000
const SLOW_REDIRECT_10S_MS = 10000
const SLOW_REDIRECT_15S_MS = 15001

// Returns a stable redirect function with timeout cleanup and a derived shouldRedirect flag
function useRedirectAfterSession(params: {
  setLogoOverride: any
  router: ReturnType<typeof useRouter>
  session: any
}) {
  const { setLogoOverride, router, session } = params
  const timeoutIdsRef = useRef<number[]>([])

  const shouldRedirect = useMemo(() => {
    const hasSuccess =
      session?.status === HostedSessionStatus.Completed &&
      !isNil(session?.success_url)
    const hasCancel =
      session?.status === HostedSessionStatus.Expired &&
      !isNil(session?.cancel_url)
    return hasSuccess || hasCancel
  }, [session])

  const clearAllTimeouts = useCallback(() => {
    timeoutIdsRef.current.forEach((id) => clearTimeout(id))
    timeoutIdsRef.current = []
  }, [])

  const redirectAfterSession = useCallback(
    (url: string) => {
      clearAllTimeouts()

      const redirectId = window.setTimeout(() => {
        setLogoOverride('')
        router.push(url)
      }, REDIRECT_DELAY_MS)

      const slow10sId = window.setTimeout(() => {
        Sentry.logger?.warn('Slow redirect at session end', {
          category: 'slow_redirect',
          message: 'Redirect took at least 10 seconds',
          organization_slug: session?.organization_slug,
        })
      }, SLOW_REDIRECT_10S_MS)

      const slow15sId = window.setTimeout(() => {
        Sentry.logger?.warn('Slow redirect at session end', {
          category: 'slow_redirect',
          message: 'Redirect took at least 15 seconds',
          organization_slug: session?.organization_slug,
        })
      }, SLOW_REDIRECT_15S_MS)

      timeoutIdsRef.current.push(redirectId, slow10sId, slow15sId)
    },
    [clearAllTimeouts, setLogoOverride, router, session]
  )

  useEffect(() => {
    return () => {
      clearAllTimeouts()
    }
  }, [clearAllTimeouts])

  return { redirectAfterSession, shouldRedirect }
}

// Returns a consistent logo value supported by HostedPageLayout: string URL or JSX element
function useLogo(
  theme: any,
  branding: any,
  logoOverride: string
): string | JSX.Element | undefined {
  return useMemo(() => {
    if (!theme?.layout?.showLogo) return undefined

    const AwellLogo = <Image src={awell_logo} alt="Awell Logo" />

    if (logoOverride && logoOverride !== '') {
      return logoOverride
    }

    if (branding?.logo_url) {
      return branding.logo_url as string
    }

    return AwellLogo
  }, [theme, branding, logoOverride])
}

// Switches on session status to render the proper view
function SessionRouter(props: {
  session: HostedSession | undefined
  shouldRedirect: boolean
}) {
  const { session, shouldRedirect } = props
  if (!session) return null

  switch (session.status) {
    case HostedSessionStatus.Active:
      return <ActivitiesContainer />
    case HostedSessionStatus.Completed:
      return <SuccessPage redirect={shouldRedirect} />
    case HostedSessionStatus.Expired:
      return <SessionExpiredPage redirect={shouldRedirect} />
    default:
      return null
  }
}

function NetworkErrorGate(props: {
  show: boolean
  branding: any
  logo: string | JSX.Element | undefined
  onCloseHostedPage: () => void
  onRetry: () => Promise<void>
  sessionId?: string
}) {
  const { show, branding, logo, onCloseHostedPage, onRetry, sessionId } = props
  if (!show) return null
  return (
    <ThemeProvider accentColor={branding?.accent_color || AWELL_BRAND_COLOR}>
      <HostedPageLayout
        logo={logo}
        onCloseHostedPage={onCloseHostedPage}
        hideCloseButton={true}
      >
        <NetworkErrorPage onRetry={onRetry} sessionId={sessionId} />
      </HostedPageLayout>
    </ThemeProvider>
  )
}

function InvalidSessionGate(props: {
  show: boolean
  branding: any
  logo: string | JSX.Element | undefined
  onCloseHostedPage: () => void
  sessionId?: string
  errorType: 'unauthorized' | 'not_found'
}) {
  const { show, branding, logo, onCloseHostedPage, sessionId, errorType } =
    props
  if (!show) return null
  return (
    <ThemeProvider accentColor={branding?.accent_color || AWELL_BRAND_COLOR}>
      <HostedPageLayout
        logo={logo}
        onCloseHostedPage={onCloseHostedPage}
        hideCloseButton={true}
      >
        <InvalidSessionPage sessionId={sessionId} errorType={errorType} />
      </HostedPageLayout>
    </ThemeProvider>
  )
}
